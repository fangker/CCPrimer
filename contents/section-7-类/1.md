## 第七章 类

__定义抽象数据类型:__
初始栗子 Sales_data 类
```c++
struct Sales_data {
  // 成员函数
  std::string isbn() const { return bookNo; }
  // 成员函数声明
  Sales_data& combine ( const Sales_data& );
  double avg_price() const;
  // 数据成员
  std::string bookNo;
  unsigned units_sold = 0;
  double revenue = 0.0;
};

// Sales_data 非成员函数声明
Sales_data add(const Sales_data&,const Sales_data& );
std::ostream &print(std::ostream&,const Sales_data& );
std::istream &read(std::istream, Sales_data& );
```
类内部定义的函数都是隐式的inline函数

__引入this:__
当调用成员隐式的我们相当于替某个对象调用它,与js类似,c++的this指向调用它的对象,所以函数成员isbn也可以这样定义。
```c++
std::string isbn() const { return this.bookNo; }
```
__引入const成员函数:__
默认情况下是this的类型是指向类类型非常量版本的常量指针。上面函数中this的默认类型是Sales_data *const.
把const放在参数列表之后,紧跟在后面的const表示this是一个指向常量的指针。这样的函数叫做常量成员函数。
相当于const 指针 指向 this(非常量对象),隐式改变了this对象的类型。
```c++
double s = 3.14;
const double *ptr = &s; // 合法
*ptr = 1; // const 保护赋值失败
// 在上述栗子中,const member function 其实就是隐式的把this(Sales_data *const)转换为了const Sales_data *const类型。
std::string isbn() const {  this->bookNo="dfsfdsf"; return this->bookNo; }
// 报错,const 保护, 不可对其进行修改.
```
__类作用域与成员函数:__
编译器先编译成员声明然后编译成员函数体,所以无需在意函数体内对编译成员的调用出现次序。

__在外部定义成员函数:__
必须保持声明匹配。在类外部定义的成员名字必须包含他所属的类名。
```c++
// 定义在类外部隐式使用this的成员
double Sales_data::avg_price() const {
  if(units_sold)
    return revenue/units_sold;
  else
    return 0;
}
```

__定义返回this对象的函数:__
```c++
Sales_data& Sales_data::combine(const Sales_data& rhs){
    units_sold += rhs.units_sold;
    revenue += rhs.revenue;
    return *this;
}
```